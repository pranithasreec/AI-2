1.Uniform cost search.
import heapq

def dijkstra(graph, start):
    # Initialize distances and predecessors
    distances = {node: float('inf') for node in graph}
    predecessors = {node: None for node in graph}
    distances[start] = 0

    # Create a priority queue for nodes to visit
    priority_queue = [(0, start)]

    while priority_queue:
        # Get the node with the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)

        # Skip if already visited
        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances, predecessors

def reconstruct_path(predecessors, start, end):
    path = []
    current_node = end
    while current_node:
        path.insert(0, current_node)
        current_node = predecessors[current_node]
    return path

# Example graph represented as an adjacency dictionary
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

start_node = 'A'
end_node = 'D'

distances, predecessors = dijkstra(graph, start_node)
shortest_path = reconstruct_path(predecessors, start_node, end_node)

print(f"Shortest distance from {start_node} to {end_node}: {distances[end_node]}")
print(f"Shortest path: {' -> '.join(shortest_path)}")


2.vaccum cleaner
class VacuumCleaner:
    def __init__(self):
        self.position = 0  # Position of the vacuum cleaner (0: Left, 1: Right)
        self.environment = [0, 0]  # Environment with dirty cells (0: Clean, 1: Dirty)

    def sense(self):
        return self.environment[self.position]

    def move(self):
        if self.position == 0:
            self.position = 1
        else:
            self.position = 0

    def clean(self):
        self.environment[self.position] = 0

    def run(self, steps):
        for _ in range(steps):
            current_state = self.sense()
            if current_state == 1:  # Dirty cell
                self.clean()
                print(f"Cleaned cell {self.position}")
            else:
                print(f"Cell {self.position} is already clean.")
            self.move()


if __name__ == "__main__":
    vacuum_cleaner = VacuumCleaner()
    steps = 5
    print("Initial environment:", vacuum_cleaner.environment)
    vacuum_cleaner.run(steps)
    print("Final environment:", vacuum_cleaner.environment)

3.Dog-Name, Size-Small, Medium and Big 
dog (fido), dog(rover), dog(jane), dog(tom), dog(fred), dog(henry), dog(fido), cat(mary), cat(harry), cat(bill), cat(steve), small(henry), medium(harry), medium(fred), large(fido), large(mary), large(tom), large(fred), large(steve), large(jim), large(mike).

4.planet database
orbits(mercury, sun).
orbits(venus, sun).
orbits(earth, sun).
orbits(mars, sun).
orbits(moon, earth).
orbits(phobos, mars).
orbits(deimos, mars).
planet(P):- orbits(P,sun).
satellite(S):- orbits(S,P),planet(P).
